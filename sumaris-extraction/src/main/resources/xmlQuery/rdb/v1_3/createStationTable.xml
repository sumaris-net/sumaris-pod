<?xml version="1.0" encoding="UTF-8"?>
<!--
  #%L
  Dali :: Core
  %%
  Copyright (C) 2017 Ifremer
  %%
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU Affero General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  #L%
  -->

<queries name="extractionCreateStationTable">

  <query type="create" temp="false" table="&amp;stationTableName" option="DISTINCT">

    <!-- PK -->
    <select alias="RECORD_TYPE" type="text">UPPER('HH')</select>
    <select alias="SAMPLING_TYPE" type="text">T.SAMPLING_TYPE</select>
    <select alias="LANDING_COUNTRY" type="text">T.LANDING_COUNTRY</select>
    <select alias="VESSEL_FLAG_COUNTRY" type="text">T.VESSEL_FLAG_COUNTRY</select>
    <select alias="YEAR" type="number">T.YEAR</select>
    <select alias="PROJECT" type="text">T.PROJECT</select>
    <select alias="TRIP_CODE" type="number">T.TRIP_CODE</select>
    <select alias="STATION_NUMBER" type="number">O.ID</select>

    <!-- other fields -->
    <select alias="FISHING_VALIDITY" type="text" group="agg">
      MAX(CASE VUM.PMFM_FK WHEN &amp;tripProgressPmfmId THEN
        CASE VUM.NUMERICAL_VALUE
          WHEN 1 THEN UPPER('V')
          WHEN 0 THEN UPPER('I')
        ELSE null END
      ELSE null END)
    </select>
    <select alias="AGGREGATION_LEVEL" type="text">UPPER('H')</select>
    <select alias="CATCH_REGISTRATION" type="text">'All'</select><!-- TODO : check batch lan/dis -->
    <select alias="SPECIES_REGISTRATION" type="text">'Par'</select><!-- TODO : check batch exhaustiveness -->
    <select alias="DATE" group="date" type="text">TO_CHAR(COALESCE(O.FISHING_START_DATE_TIME, O.START_DATE_TIME), 'YYYY-MM-DD')</select>
    <select alias="TIME" group="time" type="text">TO_CHAR(COALESCE(O.FISHING_START_DATE_TIME, O.START_DATE_TIME), 'HH24:MI')</select>

    <!-- FISHING TIME -->
    <select alias="FISHING_TIME" group="fishingTime" type="number" dbms="hsqldb">DATEDIFF('minute', COALESCE(O.FISHING_START_DATE_TIME, O.START_DATE_TIME), COALESCE(O.FISHING_END_DATE_TIME, O.END_DATE_TIME))</select>
    <select alias="FISHING_TIME" group="fishingTime" type="number" dbms="oracle">CAST(FLOOR((COALESCE(O.FISHING_END_DATE_TIME, O.END_DATE_TIME) - COALESCE(O.FISHING_START_DATE_TIME, O.START_DATE_TIME)) * 24 * 60) as INTEGER)</select>
    <select alias="FISHING_TIME" group="fishingTime" type="number" dbms="pgsql">F_DATEDIFF('minute', COALESCE(O.FISHING_START_DATE_TIME, O.START_DATE_TIME), COALESCE(O.FISHING_END_DATE_TIME, O.END_DATE_TIME))</select>

    <select alias="POS_START_LAT" type="number">P_START.LATITUDE</select>
    <select alias="POS_START_LON" type="number">P_START.LONGITUDE</select>
    <select alias="POS_END_LAT" type="number">P_END.LATITUDE</select>
    <select alias="POS_END_LON" type="number">P_END.LONGITUDE</select>

    <select alias="AREA" type="text" dbms="hsqldb,pgsql">null</select><!-- TODO get it by LOCATION_HIERARCHY -->

    <select alias="STATISTICAL_RECTANGLE" dbms="hsqldb,pgsql" type="text">
      CASE WHEN P_END.LATITUDE IS NOT NULL AND P_END.LONGITUDE IS NOT NULL THEN
        F_TO_RECTANGLE(P_END.LATITUDE, P_END.LONGITUDE)
      ELSE
        L_AREA.LABEL
      END
    </select>
    <select alias="STATISTICAL_RECTANGLE" dbms="oracle" type="text">CAST(null as VARCHAR2(10))</select> <!-- TODO Rewrite function for Oracle -->

    <!-- TODO: check if 10'x10' codification is OK
    <select alias="SUB_POLYGON" type="text">F_TO_SQUARE(P_END.LATITUDE, P_END.LONGITUDE, 10)</select>-->
    <select alias="SUB_POLYGON" type="text" dbms="hsqldb,pgsql">null</select>

    <select alias="MAIN_FISHING_DEPTH" group="agg" type="number">
      MAX(CASE VUM.PMFM_FK WHEN &amp;mainFishingDepthPmfmId THEN CAST(ROUND(VUM.NUMERICAL_VALUE) AS INTEGER) ELSE NULL END)
    </select>
    <select alias="MAIN_WATER_DEPTH" group="agg" type="number">
      MAX(CASE VUM.PMFM_FK WHEN &amp;mainWaterDepthPmfmId THEN CAST(ROUND(VUM.NUMERICAL_VALUE) AS INTEGER) ELSE NULL END)
    </select>

    <!-- TODO: check METIER -> TAXON_GROUP -> TAXON_GROUP_TYPE ? -->
    <select alias="NATIONAL_METIER" type="text" dbms="hsqldb,pgsql">null</select>
    <select alias="EU_METIER_LEVEL5" type="text">
      M.LABEL
    </select>

    <select alias="EU_METIER_LEVEL6" type="text" dbms="hsqldb,pgsql">null</select>
    <select alias="GEAR_TYPE" group="gearType" type="text">G.LABEL</select>
    <select alias="MESH_SIZE" group="agg" type="number">
      MAX(CASE PGM.PMFM_FK WHEN &amp;meshSizePmfmId THEN CAST(ROUND(PGM.NUMERICAL_VALUE) AS INTEGER) ELSE NULL END)
    </select>
    <select alias="SELECTION_DEVICE" group="agg" type="text">
      MAX(CASE PGM.PMFM_FK WHEN &amp;selectionDevicePmfmId THEN PGQV.LABEL ELSE NULL END)
    </select>

    <select alias="MESH_SIZE_IN_SELECTION_DEVICE" type="text" dbms="hsqldb,pgsql">null</select>

    <from alias="T">&amp;tripTableName</from>
    <from join="true">INNER JOIN OPERATION O ON O.TRIP_FK = T.TRIP_CODE</from>
    <from join="true">LEFT OUTER JOIN METIER M ON M.ID = O.METIER_FK</from>
    <from join="true">LEFT OUTER JOIN PHYSICAL_GEAR PG ON PG.ID = O.PHYSICAL_GEAR_FK</from>
    <from join="true">LEFT OUTER JOIN GEAR G ON G.ID = PG.GEAR_FK</from>

    <from join="true">LEFT OUTER JOIN VESSEL_USE_MEASUREMENT VUM ON VUM.OPERATION_FK = O.ID</from>
    <from join="true">LEFT OUTER JOIN QUALITATIVE_VALUE QV on QV.ID = VUM.QUALITATIVE_VALUE_FK</from>
    <from join="true">LEFT OUTER JOIN PHYSICAL_GEAR_MEASUREMENT PGM ON PGM.PHYSICAL_GEAR_FK = PG.ID</from>
    <from join="true">LEFT OUTER JOIN QUALITATIVE_VALUE PGQV on PGQV.ID = PGM.QUALITATIVE_VALUE_FK</from>

    <from join="true">LEFT OUTER JOIN FISHING_AREA FA ON FA.OPERATION_FK = O.ID</from>
    <from join="true">LEFT OUTER JOIN LOCATION L_AREA ON L_AREA.ID = FA.LOCATION_FK</from>
    <from join="true">LEFT OUTER JOIN VESSEL_POSITION P_START ON P_START.OPERATION_FK = O.ID and P_START.DATE_TIME=COALESCE(O.FISHING_START_DATE_TIME, O.START_DATE_TIME)</from>
    <from join="true">LEFT OUTER JOIN VESSEL_POSITION P_END ON P_END.OPERATION_FK = O.ID and P_END.DATE_TIME=COALESCE(O.FISHING_END_DATE_TIME, O.END_DATE_TIME)</from>

    <where>1=1</where>
    <where operator="AND" group="excludeOperationGroup"><![CDATA[
      O.START_DATE_TIME <> T.DEPARTURE_DATE_TIME AND O.END_DATE_TIME <> T.RETURN_DATE_TIME
    ]]></where>

    <groupby>&amp;groupByColumns</groupby>

<!--    <orderby direction="ASC">STATION_NUMBER</orderby>-->

  </query>

</queries>
